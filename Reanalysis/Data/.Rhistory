# Packages to call from library when opening R:
# (to add new ones to this list)
library(tidyverse)
library(dplyr)
library(vegan)
library(ggplot2)
library(cowplot)
library(RColorBrewer)
library(car)
library(reshape2)
library(scales)
library(ARTool)
library(tidyr)
library(emmeans)
library(multcomp)
library(viridis)
library(rcompanion)
library(psych)
library(devtools)
library(pairwiseAdonis)
# Loading data
setwd("/Users/talimass/Documents/Documents - MacBook Pro/GitHub/Coral-communities-along-the-depth-gradient-in-the-Red-Sea-reefs-of-Eilat/Reanalysis/Data")
lc_sf.data<-read.csv('Annotations_MO_25062024_ver1.csv',header=TRUE, stringsAsFactors = TRUE)
str(lc_sf.data)
levels(lc_sf.data$GROUP)
# because we do not really want to tread depth as continuous value,
# we will change it to be treated as factor:
lc_sf.data$DEPTH=as.factor(lc_sf.data$DEPTH)
################ calculate proportion of live:
# to summarize how many live  and how many Non_live we have per picture:
live=aggregate(Count~SITE+DEPTH+PIC+Live_Non_live, data=lc_sf.data, FUN="sum")
# to keep only live data:
live=live[live$Live_Non_live=="Live",]
# to calculate the proportion:
live$prop=live$Count/64
# add variable that gives % coverage instead of proportion
live$Cov_percent=live$prop*100
min(live$Cov_percent)
max(live$Cov_percent)
median(live$Cov_percent)
# add variable that combines site and depth
live$site_depth=paste(live$SITE, live$DEPTH, sep="_")
# install.packages("car")
library(car)
prop_data<-live$prop # on prop data of all sites & depths (just a trial)
# For depth groups:
leveneTest(prop_data~DEPTH, data=live)
library(dplyr)
library(ggplot2)
## ---- Libraries (quiet load optional) ----
suppressPackageStartupMessages({
library(dplyr)
library(ggplot2)
})
## You can either load FSA quietly OR not load it at all and just call FSA::dunnTest
suppressPackageStartupMessages(library(FSA))   # optional
## ---- Data checks ----
# Make sure SITE is a factor
live$SITE <- as.factor(live$SITE)
# Optional: drop missing values
live2 <- live %>%
filter(!is.na(prop), !is.na(SITE))
# Sample sizes per site
print(table(live2$SITE))
# Sample sizes per site
print(table(live2$SITE))
## ---- 1) Overall test: Kruskalâ€“Wallis ----
kw_site <- kruskal.test(prop ~ SITE, data = live2)
print(kw_site)
## ---- 2) Post hoc: Dunn test with multiple-comparison correction ----
# Choose method = "bh" (FDR) or "bonferroni"
dunn_site <- FSA::dunnTest(prop ~ SITE, data = live2, method = "bh")
print(dunn_site)
# Save Dunn results as a data frame (nice for reporting/export)
dunn_df <- dunn_site$res
print(dunn_df)
p_dens_depth <- ggplot(data = live, aes(x = prop, fill = DEPTH)) +
geom_density(alpha = 0.7) + # Adjust alpha for transparency if needed
scale_fill_manual(values = c("45"="slategray", "35"="lightcoral", "25"="lightseagreen", "15"="maroon", "5"="midnightblue")) +
theme_bw() +
ylim(0,3.8) + # change limit of y axis
# ggtitle("Density plot of live proportion by depth") +
xlab("Live proportion") + ylab("Density") +
theme(axis.title.x = element_text(colour="Black", size=14),
axis.title.y = element_text(colour="Black", size=14),
axis.text.x = element_text(size=12),
axis.text.y = element_text(size=12),
legend.title = element_text(size=14),
legend.text = element_text(size=14),
legend.position = c(1,1), # legend position in the top right of plot area
legend.justification = c(1,1), # legend position inside the plot area
panel.grid.major = element_blank(), # Remove major grid lines
panel.grid.minor = element_blank()  # Remove minor grid lines
)
print(p_dens_depth)
library(ARTool)
### Aligned ranks anova:
model_live <- art(prop ~ DEPTH, data = live)
anova(model_live)
### Check the success of the procedure:
model_live
### Conduct ANOVA:
anova(model_live)
# Posthoc pairwise comparison for DEPTH:
DEPTH_posthoc = art.con(model_live, "DEPTH")
DEPTH_posthoc
Sum_DEPTH = as.data.frame(DEPTH_posthoc)
# Finding the statistical group letter:
live_depth_stat_letters=as.data.frame (cldList(p.value ~ contrast, data=Sum_DEPTH))
setwd("/Users/talimass/Documents/Documents - MacBook Pro/GitHub/Coral-communities-along-the-depth-gradient-in-the-Red-Sea-reefs-of-Eilat/Reanalysis/Data")
Fun_groups_plot<-read.csv('Fun_groups_plot.csv',header=TRUE, stringsAsFactors = TRUE)
str(Fun_groups_plot)
# Change depth to factor:
Fun_groups_plot$Depth <- as.factor(Fun_groups_plot$Depth)
# Melt to long format (keep Site in the data, but we won't facet by it)
df_long <- melt(Fun_groups_plot,
id.vars = c("Site", "Depth"),
variable.name = "Category",
value.name = "Percentage")
# Create 100% stacked bar plot (ONLY BY DEPTH)
p_groups_plot <- ggplot(df_long, aes(x = Percentage, y = Depth, fill = Category)) +
geom_bar(stat = "identity", position = "fill", width = 0.6) +
scale_fill_manual(values = c(
"Other"      = "burlywood4",
"Substrate"  = "bisque3",
"Seagrass"   = "darkgreen",
"Algae"      = "darkseagreen2",
"CCA"        = "deeppink4",
"Other_Inv"  = "midnightblue",
"Sponge"     = "darksalmon",
"Soft_Coral" = "cyan3",
"Hard_Coral" = "deepskyblue4"
)) +
scale_x_continuous(labels = percent_format(accuracy = 1)) +
theme_bw() +
labs(x = "Percentage", y = "Depth (m)") +
scale_y_discrete(limits = rev(levels(df_long$Depth))) +
theme(
axis.title.x = element_text(colour = "Black", size = 16),
axis.title.y = element_text(colour = "Black", size = 16),
axis.text.x  = element_text(size = 14),
axis.text.y  = element_text(size = 14),
legend.title = element_text(size = 18),
legend.text  = element_text(size = 14)
)
print(p_groups_plot)
# to summarize how many live  and how many Non_live we have per picture:
Groups_all=aggregate(Count~DEPTH+PIC+GROUP, data=data_all, FUN="sum")
# to calculate the proportion:
Groups_all$prop=Groups_all$Count/64
# to summarize how many live  and how many Non_live we have per picture:
Groups_all=aggregate(Count~DEPTH+PIC+GROUP, data=data_all, FUN="sum")
setwd("/Users/talimass/Documents/Documents - MacBook Pro/GitHub/Coral-communities-along-the-depth-gradient-in-the-Red-Sea-reefs-of-Eilat/Reanalysis/Data")
data_all=lc_sf.data
write.csv(data_all, "data_all.csv")
Labels_corrected=read.csv("Labels_corrected_for_genus.csv", header=TRUE, stringsAsFactors = TRUE)
str(Labels_corrected)
# Importing corrected labels into data_all DF from Labels_corrected DF:
data_all$LABEL_corrected=Labels_corrected$LABEL1[match(data_all$LABEL,Labels_corrected$LABEL)]
str(data_all)
# Aggregation of observation by label by photo (73 taxons)
data_all_image=aggregate(Count~PIC+LABEL_corrected, data=data_all, FUN="sum")
# Change to %
data_all_image$coverage_label_cor=data_all_image$Count/64*100
# Adding column present / not present:
data_all_image$prevalence=ifelse(data_all_image$Count>0,1,0)
str(data_all_image)
# Pivot the DF to wide & fill 0 for 0 values using library(reshape2):
data_all_image_wide=as.data.frame(data_all_image[,c(1:2,4)] %>%
pivot_wider(names_from = LABEL_corrected, values_from = coverage_label_cor, values_fill=0))
row.names(data_all_image_wide)=data_all_image_wide$PIC
data_all_image_wide=as.data.frame(t(data_all_image_wide[,-1]))
write.csv(data_all_image_wide, "data_all_image_wide.csv")
############# Create metadata table for images using library(vegan):
metadata=unique(data_all[,1:3])
write.csv(metadata, "metadata.csv")
# Order the names (photos) in 2 DF's the same by creating the 'ord' vector:
row.names(metadata)=metadata$PIC
ord=match(colnames(data_all_image_wide), row.names(metadata))
metadata=metadata[ord,]
setwd("/Users/talimass/Documents/Documents - MacBook Pro/GitHub/Coral-communities-along-the-depth-gradient-in-the-Red-Sea-reefs-of-Eilat/Reanalysis/Data")
Fun_groups_plot<-read.csv('Fun_groups_plot.csv',header=TRUE, stringsAsFactors = TRUE)
str(Fun_groups_plot)
# Change depth to factor:
Fun_groups_plot$Depth <- as.factor(Fun_groups_plot$Depth)
# Melt to long format (keep Site in the data, but we won't facet by it)
df_long <- melt(Fun_groups_plot,
id.vars = c("Site", "Depth"),
variable.name = "Category",
value.name = "Percentage")
# Create 100% stacked bar plot (ONLY BY DEPTH)
p_groups_plot <- ggplot(df_long, aes(x = Percentage, y = Depth, fill = Category)) +
geom_bar(stat = "identity", position = "fill", width = 0.6) +
scale_fill_manual(values = c(
"Other"      = "burlywood4",
"Substrate"  = "bisque3",
"Seagrass"   = "darkgreen",
"Algae"      = "darkseagreen2",
"CCA"        = "deeppink4",
"Other_Inv"  = "midnightblue",
"Sponge"     = "darksalmon",
"Soft_Coral" = "cyan3",
"Hard_Coral" = "deepskyblue4"
)) +
scale_x_continuous(labels = percent_format(accuracy = 1)) +
theme_bw() +
labs(x = "Percentage", y = "Depth (m)") +
scale_y_discrete(limits = rev(levels(df_long$Depth))) +
theme(
axis.title.x = element_text(colour = "Black", size = 16),
axis.title.y = element_text(colour = "Black", size = 16),
axis.text.x  = element_text(size = 14),
axis.text.y  = element_text(size = 14),
legend.title = element_text(size = 18),
legend.text  = element_text(size = 14)
)
print(p_groups_plot)
# Define output directory
output_path <- "/Users/talimass/Documents/Documents - MacBook Pro/GitHub/Coral-communities-along-the-depth-gradient-in-the-Red-Sea-reefs-of-Eilat/Reanalysis/Output"
# Save plot
ggsave(
filename = file.path(output_path, "Functional groups by depth.png"),
width = 8,
height = 6,
dpi = 300
)
# to summarize how many live  and how many Non_live we have per picture:
Groups_all=aggregate(Count~DEPTH+PIC+GROUP, data=data_all, FUN="sum")
# to calculate the proportion:
Groups_all$prop=Groups_all$Count/64
# add variable that gives % coverage instead of proportion
Groups_all$Cov_percent=Groups_all$prop*100
# add variable that combines site and depth
Groups_all$site_depth=paste(Groups_all$SITE, Groups_all$DEPTH, sep="_")
str(Groups_all)
# Converting 'Groups_all' wide, adding 0 values and change it to long again:
Groups_all_image_wide=as.data.frame(Groups_all[,c(2,3,6)] %>%
pivot_wider(names_from = GROUP, values_from = Cov_percent, values_fill=0))
#Groups_all_image_wide$SITE=Groups_all$SITE[match(Groups_all_image_wide$PIC,Groups_all$PIC)]
Groups_all_image_wide$DEPTH=Groups_all$DEPTH[match(Groups_all_image_wide$PIC,Groups_all$PIC)]
str(Groups_all_image_wide)
Groups_all_image_wide_long=reshape2::melt(Groups_all_image_wide, id.vars=list("PIC", "DEPTH"))
# Subset the 'Groups_all_image_wide_long' DF for the different live functional groups (7 different DF's):
str(Groups_all_image_wide_long)
HC_df <- subset(Groups_all_image_wide_long, variable == "Hard Coral")
SC_df <- subset(Groups_all_image_wide_long, variable == "Soft Coral")
Sponge_df <- subset(Groups_all_image_wide_long, variable == "Sponge")
Other_Inv_df <- subset(Groups_all_image_wide_long, variable == "Other_Inv")
Algae_df <- subset(Groups_all_image_wide_long, variable == "Algae")
CCA_df <- subset(Groups_all_image_wide_long, variable == "CCA")
Seagrass_df <- subset(Groups_all_image_wide_long, variable == "Seagrass")
####################### HARD CORALS: ART ANOVA test & plot:
### Aligned ranks anova:
model_HC = art(value ~ DEPTH,  data = HC_df)
### Check the success of the procedure:
model_HC
### Conduct ANOVA:
anova(model_HC) # Significant for 3 factors!
# Posthoc pairwise comparison for DEPTH (if interaction significant, then posthoc for interaction is enough)::
DEPTH_HC_posthoc = art.con(model_HC, "DEPTH")
View(HC_df)
View(DEPTH_HC_posthoc)
View(DEPTH_posthoc)
DEPTH_HC_posthoc
Sum_DEPTH_HC = as.data.frame(DEPTH_HC_posthoc)
# Finding the statistical group letter:
HC_depth_stat_letters=cldList(p.value ~ contrast, data=Sum_DEPTH_HC)
write.csv(Sum_DEPTH_HC,"/Users/talimass/Documents/Documents - MacBook Pro/GitHub/Coral-communities-along-the-depth-gradient-in-the-Red-Sea-reefs-of-Eilat/Reanalysis/Output/HC_depth posthoc.csv")
write.csv(HC_depth_stat_letters,"/Users/talimass/Documents/Documents - MacBook Pro/GitHub/Coral-communities-along-the-depth-gradient-in-the-Red-Sea-reefs-of-Eilat/Reanalysis/Output/HC_depth posthoc_letters.csv")
####################### SOFT CORALS: ART ANOVA test & plot:
model_SC = art(value ~ DEPTH,  data = SC_df)
model_SC
anova(model_SC) # Significant for 3 factors!
# Posthoc pairwise comparison for the interaction:
DEPTH_SC_posthoc = art.con(model_SC, "DEPTH", adjust="tukey")
