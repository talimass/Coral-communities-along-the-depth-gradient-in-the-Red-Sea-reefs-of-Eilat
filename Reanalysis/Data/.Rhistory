library(reshape2)
library(scales)
library(ARTool)
library(tidyr)
library(emmeans)
library(multcomp)
library(viridis)
library(rcompanion)
library(psych)
library(devtools)
library(pairwiseAdonis)
# Loading data
setwd("/Users/talimass/Documents/Documents - MacBook Pro/GitHub/Coral-communities-along-the-depth-gradient-in-the-Red-Sea-reefs-of-Eilat/Reanalysis/Data")
lc_sf.data<-read.csv('Annotations_MO_25062024_ver1.csv',header=TRUE, stringsAsFactors = TRUE)
str(lc_sf.data)
levels(lc_sf.data$GROUP)
# because we do not really want to tread depth as continuous value,
# we will change it to be treated as factor:
lc_sf.data$DEPTH=as.factor(lc_sf.data$DEPTH)
################ calculate proportion of live:
# to summarize how many live  and how many Non_live we have per picture:
live=aggregate(Count~SITE+DEPTH+PIC+Live_Non_live, data=lc_sf.data, FUN="sum")
# to keep only live data:
live=live[live$Live_Non_live=="Live",]
# to calculate the proportion:
live$prop=live$Count/64
# add variable that gives % coverage instead of proportion
live$Cov_percent=live$prop*100
min(live$Cov_percent)
max(live$Cov_percent)
median(live$Cov_percent)
# add variable that combines site and depth
live$site_depth=paste(live$SITE, live$DEPTH, sep="_")
View(live)
############### Live coverage initial plot (my addition):
p_livecov <- ggplot(live, aes(x=DEPTH, y=prop,colour=DEPTH))+
geom_boxplot()+
geom_point(position=position_jitter(width=0.1))+
facet_grid(.~SITE) + # ggtitle("Live observations proportions in each site by depth") +
scale_y_continuous(labels = percent_format(accuracy = 1)) +  # Change y-axis labels to percentage
xlab("Depth (M)") + ylab("Precentage") +
#labs(colour = "Depth (M)") + # Add the legend title
theme_bw() +
theme(axis.title.x = element_text(colour="Black", size=14),
axis.title.y = element_text(colour="Black", size=14),
axis.text.x = element_text(size=12),
axis.text.y = element_text(size=12),
#legend.title = element_text(size=14),
#legend.text = element_text(size=14),
legend.position = "none",
panel.grid.major = element_blank(), # Remove major grid lines
panel.grid.minor = element_blank(), # Remove minor grid lines
strip.text = element_text(size = 18) # Increase font size of facet labels
)
print(p_livecov)
l
# install.packages("car")
library(car)
prop_data<-live$prop # on prop data of all sites & depths (just a trial)
# For depth groups:
leveneTest(prop_data~DEPTH, data=live)
p_dens <-ggplot(data = live, aes(x = prop, fill = SITE)) +
geom_density(alpha = 0.7) + # Adjust alpha for transparency if needed
scale_fill_manual(values = c("JG" = "slategray", "IUI_S"="lightseagreen", "IUI_N" = "navyblue")) +
theme_bw() +
ylim(0,3.8) + # change limit of y axis
# ggtitle("Density plot of live proportion by site") +
xlab("Live proportion") + ylab("Density") +
theme(axis.title.x = element_text(colour="Black", size=14),
axis.title.y = element_text(colour="Black", size=14),
axis.text.x = element_text(size=12),
axis.text.y = element_text(size=12),
legend.title = element_text(size=14),
legend.text = element_text(size=14),
legend.position = c(1,1), # legend position in the top right of plot area
legend.justification = c(1,1), # legend position inside the plot area
panel.grid.major = element_blank(), # Remove major grid lines
panel.grid.minor = element_blank()  # Remove minor grid lines
)
print(p_dens)
### Aligned ranks anova:
model_live = art(prop ~ DEPTH, SITE, data = live)
p_dens_depth <- ggplot(data = live, aes(x = prop, fill = DEPTH)) +
geom_density(alpha = 0.7) + # Adjust alpha for transparency if needed
scale_fill_manual(values = c("45"="slategray", "35"="lightcoral", "25"="lightseagreen", "15"="maroon", "5"="midnightblue")) +
theme_bw() +
ylim(0,3.8) + # change limit of y axis
# ggtitle("Density plot of live proportion by depth") +
xlab("Live proportion") + ylab("Density") +
theme(axis.title.x = element_text(colour="Black", size=14),
axis.title.y = element_text(colour="Black", size=14),
axis.text.x = element_text(size=12),
axis.text.y = element_text(size=12),
legend.title = element_text(size=14),
legend.text = element_text(size=14),
legend.position = c(1,1), # legend position in the top right of plot area
legend.justification = c(1,1), # legend position inside the plot area
panel.grid.major = element_blank(), # Remove major grid lines
panel.grid.minor = element_blank()  # Remove minor grid lines
)
print(p_dens_depth)
### Aligned ranks anova:
model_live = art(prop ~ DEPTH, data = live)
### Aligned ranks anova:
model_live = art(prop ~ DEPTH +SITE, data = live)
### Aligned ranks anova:
model_live = art(prop ~ DEPTH +SITE  + DEPTH:SITE,  data = live)
### Check the success of the procedure:
model_live
View(model_live)
### Aligned ranks anova:
model_live <- art(prop ~ DEPTH + SITE, data = live)
library(ARTool)
### Aligned ranks anova:
model_live <- art(prop ~ DEPTH + SITE, data = live)
############### Live coverage initial plot (my addition):
p_livecov <- ggplot(live, aes(x=DEPTH, y=prop,colour=DEPTH))+
geom_boxplot()+
geom_point(position=position_jitter(width=0.1))+
facet_grid(.~SITE) + # ggtitle("Live observations proportions in each site by depth") +
scale_y_continuous(labels = percent_format(accuracy = 1)) +  # Change y-axis labels to percentage
xlab("Depth (M)") + ylab("Precentage") +
#labs(colour = "Depth (M)") + # Add the legend title
theme_bw() +
theme(axis.title.x = element_text(colour="Black", size=14),
axis.title.y = element_text(colour="Black", size=14),
axis.text.x = element_text(size=12),
axis.text.y = element_text(size=12),
#legend.title = element_text(size=14),
#legend.text = element_text(size=14),
legend.position = "none",
panel.grid.major = element_blank(), # Remove major grid lines
panel.grid.minor = element_blank(), # Remove minor grid lines
strip.text = element_text(size = 18) # Increase font size of facet labels
)
print(p_livecov)
library(dplyr)
library(FSA)        # for dunnTest
headtail   → in psych and FSA
## ---- Libraries (quiet load optional) ----
suppressPackageStartupMessages({
library(dplyr)
library(ggplot2)
})
## You can either load FSA quietly OR not load it at all and just call FSA::dunnTest
suppressPackageStartupMessages(library(FSA))   # optional
## ---- Data checks ----
# Make sure SITE is a factor
live$SITE <- as.factor(live$SITE)
# Optional: drop missing values
live2 <- live %>%
filter(!is.na(prop), !is.na(SITE))
# Sample sizes per site
print(table(live2$SITE))
## ---- 1) Overall test: Kruskal–Wallis ----
kw_site <- kruskal.test(prop ~ SITE, data = live2)
print(kw_site)
## ---- 2) Post hoc: Dunn test with multiple-comparison correction ----
# Choose method = "bh" (FDR) or "bonferroni"
dunn_site <- FSA::dunnTest(prop ~ SITE, data = live2, method = "bh")
print(dunn_site)
## ---- Optional: Save the stats table to CSV ----
output_path <- "/Users/talimass/Documents/Documents - MacBook Pro/GitHub/Coral-communities-along-the-depth-gradient-in-the-Red-Sea-reefs-of-Eilat/Reanalysis/Output"
if (!dir.exists(output_path)) dir.create(output_path, recursive = TRUE)
write.csv(dunn_df,
file = file.path(output_path, "Dunn_posthoc_SITE_live_prop.csv"),
row.names = FALSE)
## ---- 1) Overall test: Kruskal–Wallis ----
kw_site <- kruskal.test(prop ~ SITE, data = live2)
print(kw_site)
## ---- 2) Post hoc: Dunn test with multiple-comparison correction ----
# Choose method = "bh" (FDR) or "bonferroni"
dunn_site <- FSA::dunnTest(prop ~ SITE, data = live2, method = "bh")
print(dunn_site)
# Save Dunn results as a data frame (nice for reporting/export)
dunn_df <- dunn_site$res
print(dunn_df)
## ---- Optional: Save the stats table to CSV ----
output_path <- "/Users/talimass/Documents/Documents - MacBook Pro/GitHub/Coral-communities-along-the-depth-gradient-in-the-Red-Sea-reefs-of-Eilat/Reanalysis/Output"
if (!dir.exists(output_path)) dir.create(output_path, recursive = TRUE)
write.csv(dunn_df,
file = file.path(output_path, "Dunn_posthoc_SITE_live_prop.csv"),
row.names = FALSE)
## ---- Optional: Plot (density like your figure) ----
p_site_density <- ggplot(live2, aes(x = prop, fill = SITE, color = SITE)) +
geom_density(alpha = 0.35, linewidth = 0.8) +
theme_bw() +
labs(x = "Live proportion", y = "Density") +
theme(
legend.title = element_blank(),
legend.text  = element_text(size = 12)
)
print(p_site_density)
live %>%
group_by(SITE) %>%
summarise(
n = n(),
median_cover = median(prop, na.rm = TRUE),
Q1 = quantile(prop, 0.25, na.rm = TRUE),
Q3 = quantile(prop, 0.75, na.rm = TRUE)
)
# Calculate median and quartiles
live_summary <- live %>%
group_by(SITE) %>%
summarise(
n = n(),
median_cover = median(prop, na.rm = TRUE),
Q1 = quantile(prop, 0.25, na.rm = TRUE),
Q3 = quantile(prop, 0.75, na.rm = TRUE)
)
# View results
print(live_summary)
# Define output directory (same one you used before)
output_path <- "/Users/talimass/Documents/Documents - MacBook Pro/GitHub/Coral-communities-along-the-depth-gradient-in-the-Red-Sea-reefs-of-Eilat/Reanalysis/Output"
if (!dir.exists(output_path)) dir.create(output_path, recursive = TRUE)
# Save to CSV
write.csv(
live_summary,
file = file.path(output_path, "LiveCoverage_median_quartiles_by_SITE.csv"),
row.names = FALSE
)
p_density_overall <- ggplot(live, aes(x = prop)) +
geom_density(
fill = "grey60",
colour = "black",
alpha = 0.6,
linewidth = 0.8
) +
theme_bw() +
labs(
x = "Live coral proportion",
y = "Density"
) +
theme(
legend.position = "none",
axis.title = element_text(size = 14),
axis.text  = element_text(size = 12),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()
)
print(p_density_overall)
### Aligned ranks anova:
model_live <- art(prop ~ DEPTH, data = live)
anova(model_live)
setwd("/Users/talimass/Documents/Documents - MacBook Pro/GitHub/Coral-communities-along-the-depth-gradient-in-the-Red-Sea-reefs-of-Eilat/Reanalysis/Data")
data_all=lc_sf.data
write.csv(data_all, "data_all.csv")
Labels_corrected=read.csv("Labels_corrected_for_genus.csv", header=TRUE, stringsAsFactors = TRUE)
str(Labels_corrected)
# Importing corrected labels into data_all DF from Labels_corrected DF:
data_all$LABEL_corrected=Labels_corrected$LABEL1[match(data_all$LABEL,Labels_corrected$LABEL)]
str(data_all)
# Aggregation of observation by label by photo (73 taxons)
data_all_image=aggregate(Count~PIC+LABEL_corrected, data=data_all, FUN="sum")
# Change to %
data_all_image$coverage_label_cor=data_all_image$Count/64*100
# Adding column present / not present:
data_all_image$prevalence=ifelse(data_all_image$Count>0,1,0)
str(data_all_image)
# Pivot the DF to wide & fill 0 for 0 values using library(reshape2):
data_all_image_wide=as.data.frame(data_all_image[,c(1:2,4)] %>%
pivot_wider(names_from = LABEL_corrected, values_from = coverage_label_cor, values_fill=0))
row.names(data_all_image_wide)=data_all_image_wide$PIC
data_all_image_wide=as.data.frame(t(data_all_image_wide[,-1]))
write.csv(data_all_image_wide, "data_all_image_wide.csv")
############# Create metadata table for images using library(vegan):
metadata=unique(data_all[,1:3])
write.csv(metadata, "metadata.csv")
# Order the names (photos) in 2 DF's the same by creating the 'ord' vector:
row.names(metadata)=metadata$PIC
ord=match(colnames(data_all_image_wide), row.names(metadata))
metadata=metadata[ord,]
# to summarize how many live  and how many Non_live we have per picture:
Groups_all=aggregate(Count~DEPTH+PIC+GROUP, data=data_all, FUN="sum")
# to calculate the proportion:
Groups_all$prop=Groups_all$Count/64
# add variable that gives % coverage instead of proportion
Groups_all$Cov_percent=Groups_all$prop*100
# add variable that combines site and depth
Groups_all$site_depth=paste(Groups_all$SITE, Groups_all$DEPTH, sep="_")
str(Groups_all)
# Converting 'Groups_all' wide, adding 0 values and change it to long again:
Groups_all_image_wide=as.data.frame(Groups_all[,c(2,3,6)] %>%
pivot_wider(names_from = GROUP, values_from = Cov_percent, values_fill=0))
#Groups_all_image_wide$SITE=Groups_all$SITE[match(Groups_all_image_wide$PIC,Groups_all$PIC)]
Groups_all_image_wide$DEPTH=Groups_all$DEPTH[match(Groups_all_image_wide$PIC,Groups_all$PIC)]
str(Groups_all_image_wide)
Groups_all_image_wide_long=reshape2::melt(Groups_all_image_wide, id.vars=list("PIC", "DEPTH"))
# Subset the 'Groups_all_image_wide_long' DF for the different live functional groups (7 different DF's):
str(Groups_all_image_wide_long)
HC_df <- subset(Groups_all_image_wide_long, variable == "Hard Coral")
SC_df <- subset(Groups_all_image_wide_long, variable == "Soft Coral")
Sponge_df <- subset(Groups_all_image_wide_long, variable == "Sponge")
Other_Inv_df <- subset(Groups_all_image_wide_long, variable == "Other_Inv")
Algae_df <- subset(Groups_all_image_wide_long, variable == "Algae")
CCA_df <- subset(Groups_all_image_wide_long, variable == "CCA")
Seagrass_df <- subset(Groups_all_image_wide_long, variable == "Seagrass")
####################### HARD CORALS: ART ANOVA test & plot:
### Aligned ranks anova:
model_HC = art(value ~ DEPTH,  data = HC_df)
### Check the success of the procedure:
model_HC
### Conduct ANOVA:
anova(model_HC) # Significant for 3 factors!
####################### SOFT CORALS: ART ANOVA test & plot:
model_SC = art(value ~ DEPTH,  data = SC_df)
model_SC
anova(model_SC) # Significant for 3 factors!
####################### CCA: ART ANOVA test & plot:
model_CCA = art(value ~ DEPTH, data = CCA_df)
model_CCA
anova(model_CCA) # Significant for 3 factors!
####################### SPONGES: ART ANOVA test & plot:
model_Sponge = art(value ~ DEPTH, data = Sponge_df)
model_Sponge
anova(model_Sponge) # significant for 3 factors!
####################### HARD CORALS: ART ANOVA test & plot:
### Aligned ranks anova:
model_HC = art(value ~ DEPTH,  data = HC_df)
### Check the success of the procedure:
model_HC
### Conduct ANOVA:
anova(model_HC) # Significant for 3 factors!
# Posthoc pairwise comparison for DEPTH (if interaction significant, then posthoc for interaction is enough)::
DEPTH_HC_posthoc = art.con(model_HC, "DEPTH")
DEPTH_HC_posthoc
Sum_DEPTH_HC = as.data.frame(DEPTH_HC_posthoc)
# Finding the statistical group letter:
HC_depth_stat_letters=cldList(p.value ~ contrast, data=Sum_DEPTH_HC)
# Standardize column names (cldList returns Group + Letter)
colnames(HC_depth_stat_letters) <- c("DEPTH", "Letter")
# Make DEPTH factor to match plot ordering
HC_depth_stat_letters$DEPTH <- factor(HC_depth_stat_letters$DEPTH, levels = levels(HC_df$DEPTH))
# ---- Choose x-position for letters (after coord_flip, x is value axis) ----
x_pos <- max(HC_df$value, na.rm = TRUE) * 1.05
# ---- Plot: Hard Coral coverage by depth + letters ----
p_hard <- ggplot(HC_df, aes(x = DEPTH, y = value, colour = DEPTH)) +
geom_boxplot() +
geom_point(position = position_jitter(width = 0.2)) +
ggtitle("Hard Coral coverage (%)") +
xlab("Depth (m)") + ylab("Percentage") +
theme_bw() +
coord_flip() +
# Add letters (one per depth)
geom_text(
data = HC_depth_stat_letters,
aes(x = DEPTH, y = x_pos, label = Letter),
inherit.aes = FALSE,
fontface = "bold",
size = 5
) +
theme(
axis.title.x = element_text(colour = "Black", size = 14),
axis.title.y = element_text(colour = "Black", size = 14),
axis.text.x  = element_text(size = 12),
axis.text.y  = element_text(size = 12),
legend.position = "none",  # legend not needed (depth on axis)
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.text = element_text(size = 18)
)
print(p_hard)
## ---- Clean data: remove NA depth/value, drop unused levels ----
HC_df2 <- HC_df[!is.na(HC_df$DEPTH) & !is.na(HC_df$value), ]
HC_df2$DEPTH <- droplevels(factor(HC_df2$DEPTH))
### Aligned ranks anova:
model_HC = art(value ~ DEPTH,  data = HC_df)
### Check the success of the procedure:
model_HC
### Conduct ANOVA:
anova(model_HC) # Significant for 3 factors!
## ---- Clean data: remove NA depth/value, drop unused levels ----
HC_df2 <- HC_df[!is.na(HC_df$DEPTH) & !is.na(HC_df$value), ]
HC_df2$DEPTH <- droplevels(factor(HC_df2$DEPTH))
model_HC <- art(value ~ DEPTH, data = HC_df2)
print(anova(model_HC))
HC_df2$DEPTH <- droplevels(factor(HC_df2$DEPTH))
### Aligned ranks anova:
model_HC = art(value ~ DEPTH,  data = HC_df)
### Check the success of the procedure:
model_HC
### Conduct ANOVA:
anova(model_HC) # Significant for 3 factors!
## ---- Clean data: remove NA depth/value, drop unused levels ----
HC_df2 <- HC_df[!is.na(HC_df$DEPTH) & !is.na(HC_df$value), ]
HC_df2$DEPTH <- droplevels(factor(HC_df2$DEPTH))
### Aligned ranks anova:
model_HC = art(value ~ DEPTH,  data = HC_df)
### Check the success of the procedure:
model_HC
### Conduct ANOVA:
anova(model_HC) # Significant for 3 factors!
# Posthoc pairwise comparison for DEPTH (if interaction significant, then posthoc for interaction is enough)::
DEPTH_HC_posthoc = art.con(model_HC, "DEPTH")
DEPTH_HC_posthoc
Sum_DEPTH_HC = as.data.frame(DEPTH_HC_posthoc)
# Finding the statistical group letter:
HC_depth_stat_letters <- cldList(p.value ~ contrast, data = Sum_DEPTH_HC, threshold = 0.05)
colnames(HC_depth_stat_letters) <- c("DEPTH", "Letter")
## Make DEPTH match plotting factor levels
HC_depth_stat_letters$DEPTH <- factor(HC_depth_stat_letters$DEPTH, levels = levels(HC_df2$DEPTH))
## ---- Choose a safe y-position for letters (after coord_flip, y is value) ----
# Put letters slightly to the right of the largest typical value
y_pos <- quantile(HC_df2$value, 0.98, na.rm = TRUE) * 1.05
## ---- Plot with letters ----
p_hard <- ggplot(HC_df2, aes(x = DEPTH, y = value, colour = DEPTH)) +
geom_boxplot(outlier.shape = NA) +
geom_point(position = position_jitter(width = 0.2), alpha = 0.8) +
coord_flip() +
labs(title = "Hard Coral coverage (%)", x = "Depth (m)", y = "Percentage") +
# Add letters
geom_text(
data = HC_depth_stat_letters,
aes(x = DEPTH, y = y_pos, label = Letter),
inherit.aes = FALSE,
fontface = "bold",
size = 5
) +
# Ensure there is space for the letters on the right
scale_y_continuous(limits = c(0, y_pos * 1.05), expand = expansion(mult = c(0.02, 0.05))) +
theme_bw() +
theme(
axis.title.x = element_text(colour="Black", size=14),
axis.title.y = element_text(colour="Black", size=14),
axis.text.x  = element_text(size=12),
axis.text.y  = element_text(size=12),
legend.position = "none",
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()
)
print(p_hard)
## ---- Clean data: remove NA depth/value, drop unused levels ----
HC_df2 <- HC_df[!is.na(HC_df$DEPTH) & !is.na(HC_df$value), ]
HC_df2$DEPTH <- droplevels(factor(HC_df2$DEPTH))
## ---- ART ANOVA ----
model_HC <- art(value ~ DEPTH, data = HC_df2)
print(anova(model_HC))
## ---- Post hoc for DEPTH ----
DEPTH_HC_posthoc <- art.con(model_HC, "DEPTH")
Sum_DEPTH_HC <- as.data.frame(DEPTH_HC_posthoc)
# Finding the statistical group letter:
HC_depth_stat_letters <- cldList(p.value ~ contrast, data = Sum_DEPTH_HC, threshold = 0.05)
colnames(HC_depth_stat_letters) <- c("DEPTH", "Letter")
write.csv(Sum_DEPTH_HC,"/Users/talimass/Documents/Documents - MacBook Pro/GitHub/Coral-communities-along-the-depth-gradient-in-the-Red-Sea-reefs-of-Eilat/Reanalysis/Output/HC_depth posthoc.csv")
## Make DEPTH match plotting factor levels
HC_depth_stat_letters$DEPTH <- factor(HC_depth_stat_letters$DEPTH, levels = levels(HC_df2$DEPTH))
## ---- Choose a safe y-position for letters (after coord_flip, y is value) ----
# Put letters slightly to the right of the largest typical value
y_pos <- quantile(HC_df2$value, 0.98, na.rm = TRUE) * 1.05
## ---- Plot with letters ----
p_hard <- ggplot(HC_df2, aes(x = DEPTH, y = value, colour = DEPTH)) +
geom_boxplot(outlier.shape = NA) +
geom_point(position = position_jitter(width = 0.2), alpha = 0.8) +
coord_flip() +
labs(title = "Hard Coral coverage (%)", x = "Depth (m)", y = "Percentage") +
# Add letters
geom_text(
data = HC_depth_stat_letters,
aes(x = DEPTH, y = y_pos, label = Letter),
inherit.aes = FALSE,
fontface = "bold",
size = 5
) +
# Ensure there is space for the letters on the right
scale_y_continuous(limits = c(0, y_pos * 1.05), expand = expansion(mult = c(0.02, 0.05))) +
theme_bw() +
theme(
axis.title.x = element_text(colour="Black", size=14),
axis.title.y = element_text(colour="Black", size=14),
axis.text.x  = element_text(size=12),
axis.text.y  = element_text(size=12),
legend.position = "none",
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()
)
print(p_hard)
# Finding the statistical group letter:
HC_depth_stat_letters <- cldList(p.value ~ contrast, data = Sum_DEPTH_HC, threshold = 0.05)
sum(is.na(HC_df$DEPTH))               # how many real NA?
table(HC_df$DEPTH, useNA = "ifany")   # includes NA and "NA"
unique(HC_df$DEPTH)                   # check if "NA" exists as text
## ---- Clean (remove NA in value too) ----
HC_df2 <- HC_df[!is.na(HC_df$DEPTH) & !is.na(HC_df$value), ]
HC_df2$DEPTH <- droplevels(factor(HC_df2$DEPTH))
# Optional: enforce order
HC_df2$DEPTH <- factor(HC_df2$DEPTH, levels = c("5","15","25","35","45"))
## ---- ART + posthoc letters ----
model_HC <- art(value ~ DEPTH, data = HC_df2)
DEPTH_HC_posthoc <- art.con(model_HC, "DEPTH")
Sum_DEPTH_HC <- as.data.frame(DEPTH_HC_posthoc)
HC_depth_stat_letters <- cldList(p.value ~ contrast, data = Sum_DEPTH_HC, threshold = 0.05)
colnames(HC_depth_stat_letters) <- c("DEPTH", "Letter")
HC_depth_stat_letters$DEPTH <- factor(HC_depth_stat_letters$DEPTH, levels = levels(HC_df2$DEPTH))
## ---- position for letters (y is value after coord_flip) ----
y_pos <- max(HC_df2$value, na.rm = TRUE) * 1.08
p_hard <- ggplot(HC_df2, aes(x = DEPTH, y = value, colour = DEPTH)) +
geom_boxplot(outlier.shape = NA) +
geom_point(position = position_jitter(width = 0.2), alpha = 0.8) +
coord_flip() +
geom_text(
data = HC_depth_stat_letters,
aes(x = DEPTH, y = y_pos, label = Letter),
inherit.aes = FALSE,
fontface = "bold",
size = 5
) +
scale_x_discrete(drop = TRUE) +  # <- IMPORTANT
scale_y_continuous(limits = c(0, y_pos * 1.02)) +
labs(title = "Hard Coral coverage (%)", x = "Depth (m)", y = "Percentage") +
theme_bw() +
theme(legend.position = "none")
print(p_hard)
